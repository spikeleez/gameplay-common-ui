// Copyright Spike Plugins 2026. All Rights Reserved.

#include "Framework/GameplaySetting.h"
#include "CommonHardwareVisibilityBorder.h"
#include "EditCondition/GameplaySettingEditCondition.h"
#include "Framework/Text/ITextDecorator.h"
#include "Framework/Text/RichTextMarkupProcessing.h"
#include "Misc/GameplayCommonLogs.h"
#include "Misc/Paths.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(GameplaySetting)

#define LOCTEXT_NAMESPACE "GameplayGameSetting"
#define UE_CAN_SHOW_SETTINGS_DEBUG_INFO (!UE_BUILD_SHIPPING)

namespace GameplayGameSettingsConsoleVars
{
#if UE_CAN_SHOW_SETTINGS_DEBUG_INFO
	int32 ShowDebugInfoMode = -1;

	static FAutoConsoleVariableRef CVarGameplayGameSettingsShowDebugInfo(
		TEXT("GameplayGameSettings.ShowDebugInfo"),
		ShowDebugInfoMode,
		TEXT("Should we show the developer name and class as part of dynamic details?\n")
		TEXT("  -1: Default (enabled in editor, disabled in -game or cooked builds)\n")
		TEXT("   0: Never show it\n")
		TEXT("   1: Always show it\n")
		TEXT("\n")
		TEXT("  Note: Shipping builds always disable this"),
		ECVF_Default);
#endif
}

UGameplaySetting::UGameplaySetting(const FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer)
{
	DevName = NAME_None;
	DisplayName = FText::GetEmpty();
	DisplayNameVisibility = ESlateVisibility::SelfHitTestInvisible;
	DescriptionRichText = FText::GetEmpty();
	WarningRichText = FText::GetEmpty();

	Tags = FGameplayTagContainer::EmptyContainer;

	bRefreshPlainSearchableText = true;
	bReportAnalytics = false;
	bReady = false;
	bOnSettingChangedEventGuard = false;
	bOnEditConditionsChangedEventGuard = false;
	bAdjustListViewPostRefresh = true;
}

void UGameplaySetting::Initialize(ULocalPlayer* InLocalPlayer)
{
	// If we've already gotten this local player, we're already initialized.
	if (LocalPlayer == InLocalPlayer)
	{
		return;
	}

	LocalPlayer = InLocalPlayer;

	//TODO: GameSettings
	//LocalPlayer->OnPlayerLoggedIn().AddUObject(this, &UGameSetting::RefreshEditableState, true);

#if !UE_BUILD_SHIPPING
	ensureAlwaysMsgf(DevName != NAME_None, TEXT("You must provide a DevName for the setting."));
	ensureAlwaysMsgf(!DisplayName.IsEmpty(), TEXT("You must provide a DisplayName for settings."));
#endif

	for (const TSharedRef<FGameplaySettingEditCondition>& EditCondition : EditConditions)
	{
		EditCondition->Initialize(LocalPlayer);
	}

	// If there are any child settings, go ahead and initialize them as well.
	for (UGameplaySetting* Setting : GetChildSettings())
	{
		Setting->Initialize(LocalPlayer);
	}

	Startup();
}

void UGameplaySetting::Startup()
{
	StartupComplete();
}

void UGameplaySetting::StartupComplete()
{
	ensureMsgf(!bReady, TEXT("StartupComplete called twice."));
	
	if (!bReady)
	{
		bReady = true;
		OnInitialized();
	}
}

void UGameplaySetting::Apply()
{
	OnApply();

	// Run through any edit conditions and let them know things changed.
	for (const TSharedRef<FGameplaySettingEditCondition>& EditCondition : EditConditions)
	{
		EditCondition->SettingApplied(LocalPlayer, this);
	}

	OnSettingAppliedEvent.Broadcast(this);
}


void UGameplaySetting::OnApply()
{
	// No-Op by default.
}

void UGameplaySetting::OnInitialized()
{
	ensureMsgf(bReady, TEXT("OnInitialized called directly instead of via StartupComplete."));
	EditableStateCache = ComputeEditableState();
	
	COMMON_SETTINGS_LOG(VeryVerbose, TEXT("Setting [%s] has been initialized."), *GetDevName().ToString());
}

UWorld* UGameplaySetting::GetWorld() const
{
	return LocalPlayer ? LocalPlayer->GetWorld() : nullptr;
}

void UGameplaySetting::SetSettingParent(UGameplaySetting* InSettingParent)
{
	SettingParent = InSettingParent;
}

FGameplaySettingEditableState UGameplaySetting::ComputeEditableState() const
{
	FGameplaySettingEditableState EditState;

	// Does this setting itself have any special rules?
	OnGatherEditState(EditState);

	// Run through any edit conditions
	for (const TSharedRef<FGameplaySettingEditCondition>& EditCondition : EditConditions)
	{
		EditCondition->GatherEditState(LocalPlayer, EditState);
	}

	return EditState;
}

void UGameplaySetting::OnGatherEditState(FGameplaySettingEditableState& InOutEditState) const
{
	// No-Op by default.
}

const FString& UGameplaySetting::GetDescriptionPlainText() const
{
	RefreshPlainText();
	return AutoGenerated_DescriptionPlainText;
}

void UGameplaySetting::RefreshPlainText() const
{
	// TODO: GameSettings
	// Will need to recache if the language changes.

	if (bRefreshPlainSearchableText)
	{
		TArray<FTextLineParseResults> ActualResultsArray;
		FString ActualOutput;
		FDefaultRichTextMarkupParser::GetStaticInstance()->Process(ActualResultsArray, DescriptionRichText.ToString(), ActualOutput);

		AutoGenerated_DescriptionPlainText.Reset();
		for (const FTextLineParseResults& Line : ActualResultsArray)
		{
			for (const FTextRunParseResults& Run : Line.Runs)
			{
				if (Run.Name.IsEmpty())
				{
					AutoGenerated_DescriptionPlainText.Append(ActualOutput.Mid(Run.OriginalRange.BeginIndex, Run.OriginalRange.Len()));
				}
				else if (!Run.ContentRange.IsEmpty())
				{
					AutoGenerated_DescriptionPlainText.Append(ActualOutput.Mid(Run.ContentRange.BeginIndex, Run.ContentRange.Len()));
				}
			}
		}

		bRefreshPlainSearchableText = false;
	}
}

void UGameplaySetting::NotifySettingChanged(EGameplaySettingChangeReason Reason)
{
	OnSettingChanged(Reason);
	
	COMMON_SETTINGS_LOG(Verbose, TEXT("Setting [%s] changed. Reason: %d"), *GetDevName().ToString(), (int32)Reason);
	
	// Run through any edit conditions and let them know things changed.
	for (const TSharedRef<FGameplaySettingEditCondition>& EditCondition : EditConditions)
	{
		EditCondition->SettingChanged(LocalPlayer, this, Reason);
	}

	if (!bOnSettingChangedEventGuard)
	{
		TGuardValue<bool> Guard(bOnSettingChangedEventGuard, true);
		OnSettingChangedEvent.Broadcast(this, Reason);
	}
}

void UGameplaySetting::OnSettingChanged(EGameplaySettingChangeReason Reason)
{
	// No-Op by default.
}

void UGameplaySetting::AddEditCondition(const TSharedRef<FGameplaySettingEditCondition>& InEditCondition)
{
	EditConditions.Add(InEditCondition);

	InEditCondition->OnEditConditionChanged.AddUObject(this, &ThisClass::RefreshEditableState);
}

void UGameplaySetting::AddEditDependency(UGameplaySetting* InDependencySetting)
{
	if (ensure(InDependencySetting))
	{
		InDependencySetting->OnSettingChangedEvent.AddUObject(this, &ThisClass::HandleEditDependencyChanged);
		InDependencySetting->OnSettingEditConditionChangedEvent.AddUObject(this, &ThisClass::HandleEditDependencyChanged);
	}
}

void UGameplaySetting::RefreshEditableState(bool bNotifyEditConditionsChanged)
{
	// The LocalPlayer may be destroyed out from under us, if that happens,
	// we need to ignore attempts to refresh the editable state.
	if (!LocalPlayer)
	{
		return;
	}
	
	//TODO: GameSettings
	//// We should wait until the player is fully logged in before trying to refresh settings.
	//if (!LocalPlayer->IsLoggedIn())
	//{
	//	return;
	//}

	if (!bOnEditConditionsChangedEventGuard)
	{
		TGuardValue<bool> Guard(bOnEditConditionsChangedEventGuard, true);

		EditableStateCache = ComputeEditableState();

		if (bNotifyEditConditionsChanged)
		{
			NotifyEditConditionsChanged();
		}
	}
}

void UGameplaySetting::NotifyEditConditionsChanged()
{
	OnEditConditionsChanged();

	OnSettingEditConditionChangedEvent.Broadcast(this);
}

void UGameplaySetting::OnEditConditionsChanged()
{
	// No-Op by default.
}

void UGameplaySetting::HandleEditDependencyChanged(UGameplaySetting* DependencySetting, EGameplaySettingChangeReason Reason)
{
	OnDependencyChanged();
	RefreshEditableState();

	if (Reason != EGameplaySettingChangeReason::DependencyChanged)
	{
		NotifySettingChanged(EGameplaySettingChangeReason::DependencyChanged);
	}
}

void UGameplaySetting::HandleEditDependencyChanged(UGameplaySetting* DependencySetting)
{
	OnDependencyChanged();
	RefreshEditableState();
}

void UGameplaySetting::OnDependencyChanged()
{
	// No-Op by default.
}

FText UGameplaySetting::GetDynamicDetails() const
{
	if (!LocalPlayer)
	{
		return FText::GetEmpty();
	}

	FText DynamicDetailsText = DynamicDetails.IsBound() ? DynamicDetails.Execute(*LocalPlayer) : FText::GetEmpty();

#if UE_CAN_SHOW_SETTINGS_DEBUG_INFO
	if ((GameplayGameSettingsConsoleVars::ShowDebugInfoMode == 1 || GameplayGameSettingsConsoleVars::ShowDebugInfoMode == -1) && GIsEditor)
	{
		const FString DevSettingDetails = FString::Printf(TEXT("%s<debug>DevName: %s</>\n<debug>Class: %s</>"),
			DynamicDetailsText.IsEmpty() ? TEXT("") : TEXT("\n"),
			*DevName.ToString(),
			*GetClass()->GetName()
		);

		DynamicDetailsText = FText::Format(LOCTEXT("DevDynamicDetailsFormat", "{0}{1}"), DynamicDetailsText, FText::FromString(DevSettingDetails));
	}
#endif

	return DynamicDetailsText;
}


FText UGameplaySetting::GetDynamicDetailsInternal() const
{
	return FText::GetEmpty();
}

UGameplaySetting::FGameplayStringCultureCache::FGameplayStringCultureCache(const TFunction<FString()>& InStringGetter)
	: Culture(FInternationalization::Get().GetCurrentCulture())
	, StringGetter(InStringGetter)
{
	StringCache = StringGetter();
}

void UGameplaySetting::FGameplayStringCultureCache::Invalidate()
{
	StringCache = StringGetter();
	Culture = FInternationalization::Get().GetCurrentCulture();
}

FString UGameplaySetting::FGameplayStringCultureCache::Get() const
{
	if (Culture == FInternationalization::Get().GetCurrentCulture())
	{
		return StringCache;
	}

	StringCache = StringGetter();
	Culture = FInternationalization::Get().GetCurrentCulture();

	return StringCache;
}

#undef LOCTEXT_NAMESPACE
